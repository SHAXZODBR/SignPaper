"""
AI Handler
Handles AI-powered features like summaries and quizzes.
Uses Supabase when configured, SQLite otherwise.
"""
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
import sys
sys.path.append('../..')
from database.models import (
    get_session, Theme, Book,
    get_theme, get_book, get_theme_and_book,
    use_supabase
)
from services.ai_summary import generate_summary, generate_quiz

# Import analytics tracking
try:
    from database.supabase_client import track_user_action
    ANALYTICS_AVAILABLE = True
except ImportError:
    ANALYTICS_AVAILABLE = False


async def handle_summary_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle AI Summary button click."""
    query = update.callback_query
    await query.answer("Generating AI summary... Please wait ‚è≥")
    
    callback_data = query.data
    if not callback_data.startswith('summary_'):
        return
    
    theme_id = int(callback_data.replace('summary_', ''))
    
    # Get theme with book (uses Supabase or SQLite automatically)
    theme = get_theme_and_book(theme_id)
    
    if not theme:
        await query.message.reply_text("‚ùå Theme not found.")
        return
    
    book = theme._book if hasattr(theme, '_book') else None
    
    # Track analytics
    if ANALYTICS_AVAILABLE:
        user = update.effective_user
        track_user_action(
            telegram_user_id=user.id,
            action_type="summary",
            telegram_username=user.username,
            first_name=user.first_name,
            action_data={"theme_id": theme_id}
        )
    
    # Determine content and language
    content = theme.content_uz or theme.content_ru or ""
    name = theme.name_uz or theme.name_ru or "Theme"
    language = 'uz' if theme.content_uz else 'ru'
    
    if not content or len(content) < 100:
        await query.message.reply_text(
            "‚ùå Not enough content to generate summary.\n"
            "This chapter doesn't have extracted text."
        )
        return
    
    # Generate summary
    try:
        summary = generate_summary(content, name, language)
        
        if summary:
            book_title = book.title_uz or book.title_ru if book else 'Unknown'
            response = (
                f"üìù AI Summary\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üìñ {name}\n"
                f"üìö {book_title}\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"{summary}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"ü§ñ Generated by AI"
            )
            
            # Add buttons: Refresh and Back
            keyboard = [
                [InlineKeyboardButton("üîÑ Refresh Summary", callback_data=f"summary_{theme_id}")],
                [InlineKeyboardButton("üîô Back to Theme", callback_data=f"theme_{theme_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.message.reply_text(
                response,
                reply_markup=reply_markup
            )
        else:
            await query.message.reply_text(
                "‚ùå Failed to generate summary.\n"
                "Please check that GROQ_API_KEY is set in .env file."
            )
    except Exception as e:
        await query.message.reply_text(f"‚ùå Error: {str(e)}")


async def handle_quiz_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle AI Quiz button click."""
    query = update.callback_query
    await query.answer("Generating quiz... / Test yaratilmoqda... ‚è≥")
    
    callback_data = query.data
    if not callback_data.startswith('quiz_'):
        return
    
    theme_id = int(callback_data.replace('quiz_', ''))
    
    # Get theme with book (uses Supabase or SQLite automatically)
    theme = get_theme_and_book(theme_id)
    
    if not theme:
        await query.message.reply_text("‚ùå Mavzu topilmadi / Theme not found.")
        return
    
    book = theme._book if hasattr(theme, '_book') else None
    
    # Track analytics
    if ANALYTICS_AVAILABLE:
        user = update.effective_user
        track_user_action(
            telegram_user_id=user.id,
            action_type="quiz",
            telegram_username=user.username,
            first_name=user.first_name,
            action_data={"theme_id": theme_id}
        )
    
    # Determine content and language
    content = theme.content_uz or theme.content_ru or ""
    name = theme.name_uz or theme.name_ru or "Theme"
    language = 'uz' if theme.content_uz else 'ru'
    
    if not content or len(content) < 100:
        await query.message.reply_text(
            "‚ùå Test yaratish uchun yetarli ma'lumot yo'q.\n"
            "‚ùå Not enough content to generate quiz.\n\n"
            "Bu bo'lim uchun matn chiqarilmagan."
        )
        return
    
    # Generate quiz with 5 questions (shorter to fit Telegram limit)
    try:
        # Send loading message immediately
        loading_msg = await query.message.reply_text("‚è≥ Generating 5 quiz questions...")
        
        quiz = generate_quiz(content, name, num_questions=5, language=language)
        
        # Delete loading message
        try:
            await loading_msg.delete()
        except:
            pass
        
        # Check for rate limit
        if quiz == "RATE_LIMITED":
            await query.message.reply_text(
                "‚ö†Ô∏è AI is busy! Too many requests.\n\n"
                "Please wait 30 seconds and try again.\n"
                "The free AI API has usage limits."
            )
            return
        
        if quiz:
            # Escape HTML special characters (except our spoiler tags)
            import html
            def escape_html_keep_spoilers(text):
                # First escape all HTML
                escaped = html.escape(text)
                # Then restore our spoiler tags
                escaped = escaped.replace('&lt;tg-spoiler&gt;', '<tg-spoiler>')
                escaped = escaped.replace('&lt;/tg-spoiler&gt;', '</tg-spoiler>')
                return escaped
            
            book_title = book.title_uz or book.title_ru if book else 'Unknown'
            
            safe_name = html.escape(name)
            safe_book_title = html.escape(book_title)
            safe_quiz = escape_html_keep_spoilers(quiz)
            
            response = (
                f"üìã AI Quiz - 5 Questions\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üìñ {safe_name}\n"
                f"üìö {safe_book_title}\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"Tap spoiler to reveal answer\n\n"
                f"{safe_quiz}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"ü§ñ Generated by AI"
            )
            
            # Telegram limit is 4096, split if needed
            if len(response) > 4000:
                response = (
                    f"üìã AI Quiz\n"
                    f"üìñ {safe_name[:30]}\n\n"
                    f"{safe_quiz[:3500]}"
                )
            
            # Add buttons: Refresh and Back
            keyboard = [
                [InlineKeyboardButton("üîÑ Refresh Quiz", callback_data=f"quiz_{theme_id}")],
                [InlineKeyboardButton("üîô Back to Theme", callback_data=f"theme_{theme_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.message.reply_text(
                response,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
        else:
            await query.message.reply_text(
                "‚ùå Failed to generate quiz.\n"
                "Please check that GROQ_API_KEY is set in .env file."
            )
    except Exception as e:
        print(f"Quiz error: {e}")
        await query.message.reply_text(f"‚ùå Error: {str(e)}")
